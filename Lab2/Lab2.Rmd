---
title: 'The PKSFC package: simulating simple models'
author: "Antoine Godin (Kingston University)"
date: 'Agent-based and stock-flow consistent modelling: theory and applications -
  Paris - July 17'
output:
  pdf_document: default
  ioslides_presentation: default
  slidy_presentation: default
bibliography: ../Bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(plotrix)
library(pdfetch)
library(networkD3)
library(knitr)
```

# PKSFC package

- Allowing to simulate SFC models in an open source environment}
* Still preliminary
* Only one numerical solver: Gauss-Seidel algorithm (Kinsella and O'Shea 2010)
* github.com/s120/pksfc
- Technical aspect
* R package
* EViews translator
* Read equation files
* Build model from console
* Visualization/Design tools and helpers

## Installing the dependent libraries and the package

You need to install all the required libraries This is for traditional libraries
```{r, eval=F, echo=T}
install.packages("expm")
install.packages("igraph")
```

For non-conventional libraries, such as the one need to visualize Direct Acyclical Graphs (DAG), you need to do the following
```{r,eval=F, echo=T}
source("http://bioconductor.org/biocLite.R")
biocLite("Rgraphviz")
```

Finally you can then download the PKSFC package from github and install it locally
```{r, eval=F,echo=T}
install.packages("path/PKSFC_1.5.tar.gz", repos = NULL, 
								 type="source")
```


## Testing

Now we're ready to load the package:
```{r, echo=T}
library(PKSFC)
```

1. Load SIM (download SIM.txt from Github)
```{r,echo=T}
sim<-sfc.model("Models/SIM.txt",modelName="SIMplest model 
		from chapter 3 of Godley and Lavoie (2007)")
```

2. Simulate the model
```{r,echo=T}
datasim<-simulate(sim)
```

3. replicate figure 3.2 of page 73.
```{r, width=10,echo=T,eval=T}
matplot(sim$time,datasim$baseline[,c("Yd","C")],type="l", 
	xlab="", ylab="",lwd=2,lty=c(2,3))
lines(sim$time,vector(length=length(sim$time))
	+datasim$baseline["2010","C"], lwd=2)
legend(x=1970,y=50,lwd=2, legend=c("Disposable Income",
	"Consumption","Steady State"),lty=c(2,3,1), bty="n")
``` 

## How does it work?

- The package parses a text file containing the equations
- It generates an internal representation of the model
- It checks the internal consistency of the model, the calibration
- Allows to simulate the model using a linear solver, the Gauss-Seidel Algorithm

## Source code of SIM

```{r, eval=FALSE,echo=T}
#1. EQUATIONS
C = C
G = G
T = T
N = N
Yd = W*N - T
T = theta*W*N
C = alpha1*Yd + alpha2*H_h(-1)
H = H(-1) + G - T
H_h = H_h(-1) + Yd - C
Y = C + G
N = Y/W
#2. PARAMETERS
alpha1=0.6
alpha2=0.4
theta=0.2
#EXOGENOUS
G=20
W=1
#INITIAL VALUES
H=0
H_h=0
#3. Timeline
timeline 1945 2010
```

## A few important points regarding the model source code:

- The first line of the code should be a comment line (starting with `#`)
- The file should not contain any empty lines.
- You should avoid naming your variables with reserved names in R such as 'in' or 'max'.
- There should be only one equation per line.
- There should be only one variable on the left hand side of the equation.
- You can use R functions such as min, max, or logical operators such as > or <=. In the case the logical operator returns true, the numeric value will be one. Thus `(100>10)` will return `1`.
- The lag operator is represented by `(-x)` where `x` is the lag.
- You can add as many comments, using the `#` character at the beginning of the line. Each comment exactly above an equation will be considered as the description of the equation and will be stored in the internal representation of the sfc model object.

## Internal representation

```{r, echo=T}
print(sim)
```

## Output data structure

- Output is a list of matrix where each element of the list are a scenario
	* baseline
	* scenario_i

```{r}
kable(datasim$baseline)
```

## The Gauss Seidel Algorithm

- Principle:
Solving $Ax=b,\, A\in\mathbb{R}^{n\times n},\, b\in \mathbb{R}^n$ via an iterative algorithm, where each iteration can be represented by $L x^{k+1} = b-Ux^{k},\, A=L+U$. Where $L$ is lower triangular and $U$ is upper triangular. 

- Pseudo-code:
1. Select initial values $x^0$
2. While $k<maxIter$ \& $\delta < tolValue$
	a. For each $i=1,...,n$: $$x_i^{k+1}=\frac{1}{a_{ii}}\left( b_i-\sum^{i-1}_{j=1}a_{ij} x_j^{k+1}-\sum_{j=i+1}^n a_{ij}x_j^k\right)$$
	b. Compute $\delta$: $$\delta = \frac{x^{k+1}-x^k}{x^k}$$

## System of (in)dependent equations
> See Fenell et. al (2016) 

- The Gauss-Seidel has to be used only in the case of system of dependent equations
- In other case, we only need to find order in which each variable is computed and simply compute the new value in each period
- This order is the "logical causal order" of the model and can be visualized using Direct (A)Cyclical Graphs 

## Direct Acyclic graphs

```{r, message=F, echo=T}
simex<-sfc.model("Models/SIMEX.txt",modelName="SIMplest model with expectation")
layout(matrix(c(1,2),1,2))
plot.dag(sim,main="SIM" )
plot.dag(simex,main="SIMEX" )
```

- Aside from the mathematical implication that a system of equation represent, it also has an economic meaning:
* the economy represented by SIM will adjust in one period to any shock applied to government spending. 
* for SIMEX it is not the case because consumption depend on expected disposable income which is equal to previous period disposable income. 
* in this case, the economy represented by SIMEX will adjust slowly to a shock applied to government spending, via the stocks (and particularly the buffer stock)

## In the case of a more complex model - Chapter 6 

- We can generate the plots that allow us to delve into the actual structure of the system.
- Nodes that do not form a cycle are green while nodes that form a cycle in the system are pink.
- The Gauss-Seidel needs to be applied only for the cycles

````{r, echo=T}
ch6 <- sfc.model("Models/ch6.txt",modelName="Chapter6_openmodel")
graphs = generate.DAG.collapse( adjacency = ch6$matrix )
par(mfrow = c(1,3))
# first plot the orgianl grpah
plot_graph_hierarchy( graphs$orginal_graph, main = "orginal graph" )
# plot hte nodes that form the strongly connected compoent
plot_graph_hierarchy( graphs$SCC_graph, main = "SCC nodes" )
# plot the result ing DAG when we take the condensation of the graph
plot_graph_hierarchy( graphs$DAG, main = "resulting DAG" )
````


## Systems of dependent vs independent equations

```{r,width=10,echo=T}
#Doing the simulations
datasimex<-simulate(simex)
init = datasimex$baseline[66,]
simex<-sfc.addScenario(simex,"G",25,1960,2010,init)
datasimex<-simulate(simex)
datasim<-simulate(sim)
init = datasim$baseline[66,]
sim<-sfc.addScenario(sim,"G",25,1960,2010,init)
datasim<-simulate(sim)

#Plotting it all
layout(matrix(c(1,2),1,2))
matplot(sim$time,datasim$scenario_1[,c("H","C","Yd")],
	lty=1:3,type="l",xlab="",ylab="",main="SIM")
legend(x=1944,y=130,legend=c("Wealth","Consumption",
	"Disposable Income"), lty=1:3,bty="n")
matplot(simex$time,datasimex$scenario_1[,c("H","C","Yd",
	"Yd_e")],lty=1:4,type="l",xlab="",ylab="",main="SIMEX")
legend(x=1944,y=130,legend=c("Wealth","Consumption","Disposable Income",
   "Expecetd Disposable Income"),lty=1:4,bty="n")
```

## Computational implications

Let's see how much time it takes to run sim:
```{r, echo=T}
ptm <- proc.time()
data1<-simulate(sim)
print(paste("Elapsed time is ",proc.time()[3]-ptm[3],
						"seconds"))
```

Now lets play with some of the parameters of the simulate function:

1. tolValue
```{r, echo=T}
ptm <- proc.time()
data2<-simulate(sim,tolValue = 1e-3)
print(paste("Elapsed time is ",proc.time()[3]-ptm[3],"seconds"))
```

2. maxIter
```{r,echo=T}
ptm <- proc.time()
data3<-simulate(sim, maxIter=10)
print(paste("Elapsed time is ",proc.time()[3]-ptm[3],"seconds"))
```


## Observing the results of the three simulations
```{r,echo=T}
kable(round(t(cbind(data1$baseline[c(1,2,20,40,66),c("Y")],
		data2$baseline[c(1,2,20,40,66),c("Y")],
		data3$baseline[c(1,2,20,40,66),c("Y")])),digits=3))
```


## Block Gauss-Seidel
The order of equations matters, if first compute variables that do not depend on current period, this speeds the process. Define blocks of equation independent from the others.
```{r,echo=T}
print(simex$blocks)
```


## Simulation of SIMEX
```{r,echo=T}
ptm <- proc.time()
dataex<-simulate(simex,tolValue = 1e-10)
print(paste("Elapsed time is ",proc.time()[3]-ptm[3]
						,"seconds"))
```


## Results for SIMEX
```{r,echo=T}
kable(round(t(dataex$baseline[c(1,2,20,40,66),c("G","Y",
	"T","Yd","Yd_e","C","H","H_h")]),digits=3))
```

## Output data structure
- Output is a list of matrix where each element of the list are a scenario
* baseline
* scenario_i
- In the result matrix, there is a column indicating the number of iteration in the Gauss-Seidel algorithm per block of equations per period

```{r, echo=T, eval=T}
kable(dataex$baseline)
```


## Checking the number of iteractions for SIM


```{r, echo=T}
kable(round(t(cbind(
	data1$baseline[c(1,2,20,40,66),c("iter block 1")],
	data2$baseline[c(1,2,20,40,66),c("iter block 1")],
	data3$baseline[c(1,2,20,40,66),c("iter block 1")]
	)),digits=3))
```

## Checking the number of iteractions for simex, no simulate parameters
```{r, echo=T}
kable(round(t(dataex$baseline[c(1,2,20,40,66),
	c("iter block 1","iter block 2","iter block 3",
	"iter block 4","iter block 5","iter block 6",
	"iter block 7")]),digits=3))
```

# Visualisation

- Interactions with economists (mainstream and less)
	* Importance of stock and flow dimensions (Bezemer et al. 2015)
	* Importance of clearing mechanisms for markets under uncertainty (Foley 1975)
	* Importance of disequilibrium mechanics, path dependency, etc...
- Interactions with students
	* Undergrad level, with dynamic models without coding (Shiny, Mathematica, ...): simple pK results such as endogenous money, paradox of thrift, Minskian dynamics, etc.
	* Postgraduate level, integrated with R: sectoral accounts (empirical), mathematical properties (causal structure, solutions), more complex pK results and model building (PKSFC package)
- Interactions with policy makers
	* Importance of visualization (results, causal structure)
	* Importance of interactions with the model
	* Importance of real-world structures

## Visualisation - Sankey Diagram

![Flows in the UK Economy 2014, source: Burgess et al. (2016)](Pictures/SankeyUpdated.png)

## Visualisation - Graph representation

- Fenell et al. (2015) show that each SFC model can be perceived as a Direct Acyclic Graph, which allows to understand the internal causal structure of the model (imposed).
- Practically, all endogenous variables are nodes and there if a variable appears in the equation determining another, there is vertex between the two nodes.
- Its is then possible to plot the graph and observe the structure of the model.
- In the following graphs, nodes that are part of a system of dependent equations are highlighted in pink.

## Example with models SIM-SIMEX

![Graph representation of SIM and SIMEX, source: author's computation](Pictures/SIM_SIMEX_DAG.png)

## Shock propagation in more complex models

![Graph representation of Burgess et al. (2016)](Pictures/Origin.png)

## Shock to CAR - Direct

![Graph representation of Burgess et al. (2016)](Pictures/Lag0.png)

## Shock to CAR - Lag 1: Interest rates

![Graph representation of Burgess et al. (2016)](Pictures/Lag1.png)

## Shock to CAR - Lag 2: Income and profits

![Graph representation of Burgess et al. (2016)](Pictures/Lag2.png)

## Dynamical interaction with models 
>[antoinegodin.shinyapps.io/SIMEX](antoinegodin.shinyapps.io/SIMEX)

![Shiny application](Pictures/Shiny.png)

# Model with Portfolio choice


## Balance Sheet


| |Households|Production|Government|Central Bank| Sum|
|:------:|:------:|:------:|:------:|:------:|:------:|
|Money|+H| | |-H|	0|
|Bills|+Bh| |-B|+Bcb|0|
|Net worth|-V| |+V||0|
|Sum|0|0|0|0|0|


## Transaction Flow Matrix

| |Households|Production|Government|Central Bank| Sum|
|:------:|:------:|:------:|:------:|:------:|:------:|
|Consumption|-C|+C| | |	0|
|Gov. Exp.||+G|-G||0|
|Income = GDP|+Y|-Y| ||0|
|Interests|+r(-1)*Bh(-1)||-r(1)*B(-1) |+r(-1)*Bcb(-1)|0|
|CB profits|||+r(-1)*Bcb(-1) |-r(1)*Bcb(-1)|0|
|Taxes|-T||+T||0|
|Change in Money|-$\Delta$ H| ||+$\Delta$ H|0|
|Change in Bills|-$\Delta$ Bh| |+$\Delta$ B|-$\Delta$ Bcb|0|
|Sum|0|0|0|0|0|

## Behavioural Equations (from PC.txt file)

```{r,eval=F,echo=T,split=T}
#######Determination of output - eq. 4.1
y = cons + g
#######Disposable income - eq. 4.2
yd = y - t + r(-1)*b_h(-1)
#######Tax payments - eq. 4.3
t = theta*(y + r(-1)*b_h(-1))
#######Wealth accumulation - eq. 4.4
v = v(-1) + (yd - cons)
#######Consumption function - eq. 4.5
cons = alpha1*yd + alpha2*v(-1)
#######Cash money - eq. 4.6
h_h = v - b_h  
#######Demand for government bills - eq. 4.7
b_h = v*(lambda0 + lambda1*r - lambda2*(yd/v))
#######Supply of government bills - eq. 4.8
b_s = b_s(-1) + (g + r(-1)*b_s(-1)) - (t + r(-1)*b_cb(-1))
#######Supply of cash - eq. 4.9
h_s = h_s(-1) + b_cb - b_cb(-1)
#######Government bills held by the central bank - eq. 4.10
b_cb = b_s - b_h
#######Interest rate as policy instrument - eq. 4.11
r = r_bar
```

## Portfolio Equations

How to allocate wealth between bills and money?

1. Quantity theory of money: links money balances to the flow of income
2. Liquidity preferences: money balances some proportion of total wealth

Merging the two into Tobin's portfolio equations:

\begin{align}
\frac{H_h}{V}&=(1-\lambda_0)-\lambda_1\cdot r+\lambda_2\cdot\left(\frac{YD}{V}\right)\tag{4.6A}\\
\frac{B_h}{V}&=\lambda_0+\lambda_1\cdot r-\lambda_2\cdot\left(\frac{YD}{V}\right)\tag{4.7}\\
H_h&=V-B_h\tag{4.6}
\end{align}


## Setting up the environment

Before doing any modelling, we need to load the package in the R environment. 
```{r,echo=T}
library(PKSFC)
```

Then, you need to download the attached 'PC.txt' file and save it in the folder of your choice. Make sure to set the working directory where you saved the downloaded file. In command line this looks like this but if you use Rstudio, you can use the graphical interface as well (Session>Set Working Directory>Choose Directory)
```{r,echo=T, eval=FALSE}
setwd("pathToYourDirectory")
```

## Loading the model

The first thing to do is to load the model and check for completeness.
```{r,echo=T}
pc<-sfc.model("Models/PC.txt",modelName="Portfolio Choice Model")
pc<-sfc.check(pc,fill=FALSE)
```

Let's have a look at the graphical representation of model PC. In order to do so, we need to load the `Rgraphviz` library:
```{r,echo=T}
library("Rgraphviz")
```

We can now look at the graph of model PC:
```{r,echo=T}
plot.dag(pc,main="PC" )
```

You can see that there is a cycle in the graph, implying that GDP, taxes, disposable income and consumption are determined all together (and that they fully adapt to any shock applied to the economy). While this is a mathematical property of the system of equations representing the economy we wish to model, it has an economic meaning and you want to be sure that this is what you believe to be the best representation of what you have in mind.

We are now ready to simulate the model
```{r,echo=T}
datapc<-simulate(pc)
```

## Expectations and random shocks

The first of experiment is meant to observe the buffer role of money, in case of random shocks applied to expected disposable income. To do these, we need to modify slightly model pc and change the equations determining consumption, demand for bonds and money, and the expectations on income and wealth. We will call the new model pcRand.

```{r,echo=T}
pcRand<-sfc.editEqus(pc,list(list(var="cons",eq="alpha1*yde+alpha2*v(-1)"),
      list(var="b_h",eq="ve*(lambda0 + lambda1*r - lambda2*(yde/ve))")))
pcRand<-sfc.addEqus(pcRand,list(
  list(var="yde",eq="yd(-1)*(1+rnorm(1,sd=0.1))",
  		 desc="Expected disposable income depending on random shocks"),
  list(var="h_d",eq="ve-b_h",desc="Money demand"),
  list(var="ve",eq="v(-1)+yde-cons",desc="Expected disposable income")))
pcRand<-sfc.editVar(pcRand,var="yd",init=86.48648)
pcRand<-sfc.check(pcRand)
```

You probably have noticed that the `yde` equation contains the R function `rnorm` which allows you to extract a random number from a normal distribution centred around 0, with standard variation of 0.1. The package indeed allows you to use any R function such as `min`, `max` or `rnorm`. However, because of the way the Gauss-Seidel algorithm works, we are facing a problem. Indeed, as the `rnorm` function extract a number in each iteration, this will mean that the algorithm cannot converge since the difference between each iteration of the algorithm depends of the difference between each extraction. This is why we need to restrict the number of iteration of the Gauss-Seidel.

Before simulating the model, let's have a look at how the graph of the model has changed:
```{r,echo=T}
plot.dag(pcRand,main="PC Random" )
```

You can now see that the cycle observed in the original model has disappeared. Indeed, consumption doesn't depend on disposable income any more but on expected disposable income. Let's now simulate the model.
```{r,echo=T}
datapcRand<-simulate(pcRand,maxIter=2)
```

This replicates figure 4.1, page 110
```{r,echo=T}
plot(pcRand$time,datapcRand$baseline[,"h_h"],type="l",xlab="",ylab="",lty=1,lwd=2,
     ylim=c(1*min(datapcRand$baseline[,c("h_h","h_d")],na.rm=T),
            1.2*max(datapcRand$baseline[,c("h_h","h_d")],na.rm=T)))
lines(pcRand$time,datapcRand$baseline[,"h_d"],lty=2,lwd=2)
legend(x=1950,y=1.2*max(datapcRand$baseline[,c("h_h","h_d")],na.rm=T),
       legend=c("Money held","Money demand"),lty=c(2,1),lwd=2,bty="n")
```

This graph highlights the buffer role of certain stocks in PK-SFC models. Indeed, because expectations are incorrect or because demand might not be equal to supply in any market, at least one stock will not be equal to the targeted level. As highlighted by @Foley:1975, in a model without perfect foresight you need a buffer stock in order to obtain equilibrium between demand and supply. The role of buffer stocks in PK-SFC model is thus fundamental and is at the hart of the approach used by @Godley:1999c in his seven unsustainable processes. It is by observing the dynamics of certain stock-flow norms that you are able to observe the unsustainable processes evolving in an economy, because stocks precisely absorb disequilibrium.

## Interest rates impacts

The graphs presented on the paper are based on the model PCEX, which includes expectation on disposable income and wealth. We will first create the model before simulating it.The shock represents an 100 basis point increase in interest rates.

```{r,echo=T}
pcex<-sfc.editEqus(pc,list(
  list(var="cons",eq="alpha1*yde+alpha2*v(-1)"),
  list(var="b_h",eq="ve*(lambda0 + lambda1*r - lambda2*(yde/ve))")))
pcex<-sfc.addEqus(pcex,list(
  list(var="yde",eq="yd(-1)",desc="Expected disposable income"),
  list(var="h_d",eq="ve-b_h",desc="Money demand"),
  list(var="ve",eq="v(-1)+yde-cons",desc="Expected disposable income")))
pcex<-sfc.editVar(pcex,var="yd",init=86.48648)
pcex<-sfc.check(pcex)
init = datapc$baseline[56,]
pcex<-sfc.addScenario(model=pcex,vars="r_bar",values=0.035,inits=1960,
											ends=2010,starts=init)
datapcex<-simulate(pcex)
```

This replicates plot figure 4.3. p. 112
```{r,echo=T}
time2=c(1950:2000)
plot(time2, datapcex$scenario[as.character(time2),"h_h"]/
		 	datapcex$scenario[as.character(time2),"v"],
		 type="l",xlab="",ylab="",lty=1,lwd=2)
par(new=T)
plot(time2,datapcex$scenario[as.character(time2),"b_h"]/
		 	datapcex$scenario[as.character(time2),"v"],
     lty=2, lwd=2,type="l",axes=F,ylab="",xlab="")
axis(4,pretty(c(0.750, 1.1*max(datapcex$scenario[,"b_h"]/
			datapcex$scenario[,"v"],na.rm=T))))
legend(x=1970,y=0.78,legend=c("Share of Bills",
		"Share of Money"),lty=c(2,1),lwd=2,bty="n")
grid()
```

No surprise here, the change in return rates coming from the shock led to a re-allocation between Bills and Money, in favour of the former.

This replicates fig 4.4 . p 113
```{r,echo=T}
time2=c(1950:2000)
matplot(time2,datapcex$scenario[as.character(time2),c("yd","cons")]
				,type="l",xlab="",ylab="",lty=1:2,col=1,lwd=2)
legend(x=1970,y=88,legend=c("Disposable Income","Consumption"),
			 lwd=c(2,2),lty=c(1,2),bty="n")
grid()
```

These results are more surprising as increased interest rates lead to an increase both in disposable income and consumption. To understand this, one has to bear in mind that increase in interest rates leads to an increase in government spending and thus to an increase in the *fiscal stance* which determines the steady state:

$Y^\star=\frac{G+r \cdot B^{\star}_h \cdot (1-\theta)}{\theta}$


## Endogenous propensities to consume

We change the propensities to consume to incorporate the fact that they might be impacted by interest rates and thus have

\begin{equation}
\alpha_1=\alpha_10-\iota\cdot r_{-1} \tag{4.32}
\end{equation}

This piece of code shows how to implement this

```{r,echo=T}
pc_end<-sfc.addEqus(pcex,list(
  list(var="alpha1",eq="alpha10-iota*r(-1)")))
pc_end<-sfc.addVars(pc_end,list(
  list(var="alpha10",init="0.7",
  		 desc="Endoegnous propensity to consume - autonomous term"),
  list(var="iota",init="10",
  		 desc="Endoegnous propensity to consume - interest rate impact")))
pc_end$scenarios<-NULL
pc_end<-sfc.check(pc_end)
datapc_end<-simulate(pc_end)
init = datapc_end$baseline[56,]
pc_end<-sfc.addScenario(model=pc_end,vars="r_bar",values=0.035,
												inits=1960,ends=2010,starts=init)
datapc_end<-simulate(pc_end)
```

This replicates plot figure 4.9. p. 123
```{r,echo=T}
time2=c(1950:2000)
matplot(time2,
     datapc_end$scenario_1[as.character(time2),c("v","yd","cons","y")],
     type="l",xlab="",ylab="",lty=1:4,lwd=2,col=1)
grid()
legend(x=1950,y=100,legend=c("Households wealth","Disposable income",
			"Consumption","GDP"),lty=1:4,lwd=2,bty="n")
```

This shows that now the short-term dynamics display the Keynesian *paradox of thrift* but the long-run steady state still shows a positive impact of interests rates on GDP. The short-run recession is governed by the decrease in the propensity to consumed and is slowly compensated by the increase in wealth (and the increased public debt as a counterpart) leading to the new steady state. The steady state is still driven by the fiscal stance.

This replicates plot figure 4.10. p. 123
```{r,echo=T}
timelag=c(1950:2000)
time2=c(1951:2001)
plot(time2,
     datapc_end$scenario_1[as.character(time2),c("g")]+
		 	datapc_end$scenario_1[as.character(timelag),c("r")]*
		 	datapc_end$scenario_1[as.character(timelag),c("b_s")]-
		 	datapc_end$scenario_1[as.character(timelag),c("r")]*
		 	datapc_end$scenario_1[as.character(timelag),c("b_cb")],
     type="l",xlab="",ylab="",lty=1:4,lwd=2,col=1,ylim=c(20.8,23))
lines(time2,datapc_end$scenario_1[as.character(time2),"t"],type="l",xlab="",
			ylab="",lty=2,lwd=2)
grid()
legend("topleft",legend=c("Government expenditures plus net debt services",
			"Tax revenues"),lty=1:4,lwd=2,bty="n")
```


## Debt to GDP at the steady state

\begin{equation}
\frac{V^\star}{Y^\star}=\frac{\frac{1-\alpha_1}{\alpha_2}}{1+\left[\frac{\theta}{1-\theta}\right]-r\cdot \left[(\lambda_0+\lambda_1\cdot r)\cdot \frac{1-\alpha_1}{\alpha_2}-\lambda_2\right]}\tag{4.33}
\end{equation}

The Maastricht treaty: The reference values referred to [...] are:

- 3\% for the ratio of the planned or actual government deficit to gross domestic product at market 
- 60\% for the ratio of government debt to gross domestic product at market prices. 

# Liquidity Preferences and model LP

## Value of perpetuity, interest rates, exepcted returns and capital gains

The value of a financial asset is supposed to reflect the net present value of future cash flows. Thus for a long-term bond who is never redeemed, the price $p_{bL}$ of the bond is given by 

$p_{bL} = \sum \frac{1}{(1+r_{bL})^t} = \frac{1}{r_{bL}}$

Return rate of an asset is equal to both the yield (interests, dividends) and the capital gains normalized to the nominal value of the asset. In the case of a long-term bond:

$Rr_{bL} = r_{bL}(-1)+\frac{\Delta p_{bL}}{p_{bL}(-1)} = \frac{1+p_{bL}-p_{bL}(-1)}{p_{bL}(-1)}$

However, what matter for the households when making their decision is the expected price of bonds $p_{bL}^e$, given the current price of bonds. This leads to the *pure expected rate of return*.

$PERr_{bL} = r_{bL} + \frac{p^e_{bL}-p_{bL}}{p_{bL}}$

Because expectation are not followed by everyone, households might incorporate a weight $\xi$ into their expectation formation. This leads to the *expected return rate*

$ERr_{bL} = r_{bL} + \xi \frac{p^e_{bL}-p_{bL}}{p_{bL}}$

The change in prices of bonds leads to capital gains which is one of two parts of the change in nominal value of financial assets. More precisely:

\begin{align*}
\Delta (p_{BL}\cdot BL) &=\left(p_{bL} \cdot BL\right) - \left(p_{bL}(-1) \cdot BL(-1)\right)\\
&= p_{BL} \cdot BL-p_{BL}\cdot BL(-1) + p_{BL}\cdot BL(-1)-p_{bL}(-1) \cdot BL(-1)\\
&= p_{BL} \left( BL-BL(-1)\right) + BL(-1) \left(p_{BL}-p_{BL}(-1)\right)\\
&= p_{BL} \cdot \Delta BL+ BL(-1)\cdot \Delta p_{BL}
\end{align*}

Thus total changes in nominal values of an asset is equal to the quantity of assets bought (or sold) at the current price ($p_{BL} \cdot \Delta BL$) and to the capital gains (or losses) made on the stock of assets held at the beginning of the period ($BL(-1)\cdot \Delta p_{BL}$)

![Ostergaard diagram](Pictures/Ostergaard.png)

## Balance Sheet


| |Households|Production|Government|Central Bank| Sum|
|:------:|:------:|:------:|:------:|:------:|:------:|
|Money|+H| | |-H|	0|
|Bills|+Bh| |-B|+Bcb|0|
|Bonds|+BL.pbL| |-BL.pbL| |0|
|Net worth|-V| |+V||0|
|Sum|0|0|0|0|0|


## Transaction Flow Matrix

| |Households|Production|Government|Central Bank| Sum|
|:------:|:------:|:------:|:------:|:------:|:------:|
|Consumption|-C|+C| | |	0|
|Gov. Exp.||+G|-G||0|
|Income = GDP|+Y|-Y| ||0|
|Interests on bills|+rb(-1)*Bh(-1)||-rb(1)*B(-1) |+rb(-1)*Bcb(-1)|0|
|Interests on bonds|+BL(-1)||-BL(-1) ||0|
|CB profits|||+r(-1)*Bcb(-1) |-r(1)*Bcb(-1)|0|
|Taxes|-T||+T||0|
|Change in Money|-$\Delta$ H| ||+$\Delta$ H|0|
|Change in Bills|-$\Delta$ Bh| |+$\Delta$ B|-$\Delta$ Bcb|0|
|Change in Bonds|-$\Delta$ BL.pbL| |+$\Delta$ BL.pbL| |0|
|Sum|0|0|0|0|0|
|*Memo: Capital gains*|-$\Delta$ pbL.BL(-1)||+$\Delta$ pbL.BL(-1)||0|

## Equation list

```{r,eval=F,echo=T}
# MODEL
# Determination of output - eq. 5.1
y = cons + g
# Regular disposable income - eq. 5.2
yd_r = y - t + r_b(-1)*b_h(-1) + bl_h(-1)
# Tax payments - eq. 5.3
t = theta*(y + r_b(-1)*b_h(-1) + bl_h(-1))
# Wealth accumulation - eq. 5.4
v = v(-1) + (yd_r - cons) + cg
# Capital gains on bonds - eq. 5.5
cg = (p_bl-p_bl(-1))*bl_h(-1)
# Consumption function - eq. 5.6
cons = alpha1*yd_r_e + alpha2*v(-1)
# Expected wealth - eq. 5.7
v_e = v(-1) + (yd_r_e - cons) + cg
# Cash money - eq. 5.8
h_h = v - b_h - p_bl*bl_h
# Demand for cash - eq. 5.9
h_d = v_e - b_d - p_bl*bl_d
# Demand for government bills - eq. 5.10
b_d = v_e*(lambda20 + lambda22*r_b - lambda23*er_rbl - lambda24*(yd_r_e/v_e))
# Demand for government bonds - eq. 5.11
bl_d = v_e*(lambda30 - lambda32*r_b + lambda33*er_rbl - lambda34*(yd_r_e/v_e))/p_bl
# Bills held by households - eq. 5.12
b_h = b_d
# Bonds held by households - eq. 5.13
bl_h = bl_d
# Supply of government bills - eq. 5.14
b_s = b_s(-1) + (g + r_b(-1)*b_s(-1) + bl_s(-1)) - (t + r_b(-1)*b_cb(-1)) -p_bl*(bl_s-bl_s(-1))
# Supply of cash - eq. 5.15
h_s = h_s(-1) + b_cb - b_cb(-1)
# Government bills held by the central bank - eq. 5.16
b_cb = b_s - b_h
# Supply of government bonds - eq. 5.17
bl_s = bl_h
# Expected rate of return on bonds - eq. 5.18
er_rbl = r_bl+chi*(p_bl_e - p_bl)/p_bl
# Interest rate on bonds - eq. 5.19
r_bl = 1/p_bl
# Expected price of bonds - eq. 5.20
p_bl_e = p_bl
# Expected capital gains - eq. 5.21
cg_e = chi*(p_bl_e - p_bl)*bl_h
# Expected regular disposable income - eq. 5.22
yd_r_e = yd_r(-1)
# Interest rate on bills - eq. 5.23
r_b = r_bar
# Price of bonds - eq. 5.24
p_bl = p_bl_bar
```

Let's have a look at the graph of model LP

```{r,echo=T}
lp<-sfc.model(fileName="Models/LP.txt",modelName="Model Liquidity Preference")
plot.dag(lp)
```

## The adding up of the portfolio behavior

The vertical conditions state that the sum of the exogenous components sums to 1, i.e. you cannot allocate more than the wealth and that the effect of the various return rates and disposable income are subtracting the holding of one asset to allow the increase of the holding of another.

\begin{align}
\lambda_{10} + \lambda_{20} + \lambda_{30} &= 1 \tag{ADUP.1}\\
\lambda_{11} + \lambda_{21} + \lambda_{31} &= 0 \tag{ADUP.2}\\
\lambda_{12} + \lambda_{22} + \lambda_{32} &= 0 \tag{ADUP.3}\\
\lambda_{13} + \lambda_{23} + \lambda_{33} &= 0 \tag{ADUP.4}\\
\lambda_{14} + \lambda_{24} + \lambda_{34} &= 0 \tag{ADUP.5}
\end{align}

The horizontal conditions, added by Godley (1996) state that the impact of an increase in the 'own rate' of an asset should be equal to the impact of a fall in all the other rates.

\begin{align}
\lambda_{11} &= - \left( \lambda_{12} + \lambda_{13}\right) \tag{ADUP.6}\\
\lambda_{22} &= - \left( \lambda_{21} + \lambda_{23}\right) \tag{ADUP.7}\\
\lambda_{33} &= - \left( \lambda_{31} + \lambda_{32}\right) \tag{ADUP.8}
\end{align}

Other authors propose the symmetry conditions that state that an increase in the return rate of one asset A will have the same impact on the holding of asset B as the increase in the return rate of asset B will have on the holding of asset A

\begin{align}
\lambda_{12} &= \lambda_{21} \tag{ADUP.9}\\
\lambda_{13} &= \lambda_{31} \tag{ADUP.10}\\
\lambda_{23} &= \lambda_{32} \tag{ADUP.11}
\end{align}

Note that vertical + symmetry imply automatically horizontal but that vertical + horizontal does not necessarily imply symmetry.

## Higher interest rates

The first scenario run looks at the impact of interest rates (short- and long-term) on real demand. We assume that the government increases short-term rates from 3% to 4% and the long-term rate from 5% to 6.66%. We assume that this increase is completely unexpected and that the Treasury is believed in that no other change will occur.

```{r,echo=T}
lp<-sfc.addScenario(model=lp,vars=list(c("r_bar","p_bl_bar")),values=list(c(0.04,15)),
							inits=1960,ends=2000)
datalp<-simulate(lp)
```

This replicates plot figure 5.2. p. 152
```{r,echo=T}
time2=c(1950:2000)
plot(time2, datalp$scenario_1[as.character(time2),"v"]/
		 	datalp$scenario[as.character(time2),"yd_r"],
		 type="l",xlab="",ylab="",lty=1,lwd=2)
legend("bottomright",legend=c("Wealth to income ratio"),lty=c(1),lwd=2,bty="n")
grid()
```

We see that the increase in long-term interest rate leads to capital losses on bonds, leading to a decrease in wealth to income ratio. However because interest rates have increase, households have now a higher disposable income leading to a replenishing of their wealth. Note that as in model PC, the steady state GDP is given by

$Y^\star=\frac{G+\left(r_B\cdot B^{\star}_h+BL_S^\star\right) \cdot (1-\theta)}{\theta} = \frac{G_{NT}}{\theta}$

This replicates plot figure 5.3. p. 152
```{r,echo=T}
time2=c(1950:2000)
matplot(time2, datalp$scenario_1[as.character(time2),c("yd_r","cons")],
		 type="l",xlab="",ylab="",lty=c(1,2), col=1,lwd=2)
legend("topleft",legend=c("Disposable income","Consumption"),lty=c(1,2),lwd=2,bty="n")
grid()
```

This replicates plot figure 5.4. p. 153
```{r,echo=T}
time2=c(1950:2000)
matplot(time2, cbind(datalp$scenario_1[as.character(time2),c("b_h")],
			datalp$scenario_1[as.character(time2),c("p_bl")]*
			datalp$scenario_1[as.character(time2),c("bl_h")])/
				datalp$scenario_1[as.character(time2),c("v")],
		 type="l",xlab="",ylab="",lty=c(1,2), col=1,lwd=2)
legend("center",legend=c("Bonds to wealth ratio","Bills to wealth ratio"),
		lty=c(2,1),lwd=2,bty="n")
grid()
```

## Introducing household liquidity

In order to introduce liquidity preferences, we need to modify the model. The first modification is to change the expectation on bonds price to include (i) a learning element and (ii) a stochastic term. Because expectation are going to play a role, we also need to modify the price equation for bonds such that it now reflects a corridor approach to bond pricing. The assumption is thus that the Treasury will try to pin down the price of bonds but only to a certain extent. If the demand is too large (or too low) the treasury will let prices (and interest) float. We assume that the government aims at a certain debt structure in terms of maturity.

```{r,echo=T}
#Adding the equations
lp2<-sfc.addEqus(lp,list(
	list(var="z1",equ = "TP>top"),
	list(var="z2",equ = "TP<bot"),
	list(var="TP",equ = "(bl_h(-1)*p_bl(-1))/(bl_h(-1)*p_bl(-1)+b_h(-1))")))
#Adding the parameters
lp2<-sfc.addVars(lp2,list(
	list(var="betae",init=0.5),
	list(var="beta",init=0.01),
	list(var="add",init=0),
	list(var="top",init=0.495),
	list(var="bot",init=0.505)
))
#Adding initial values to the endogenous variables that have lags
lp2<-sfc.editEnd(lp2,var="p_bl_e", init=20)
lp2<-sfc.editEnd(lp2,var="p_bl", init=20)
#Modifying the existing equations
lp2<-sfc.editEqus(lp2,list(
	list(var="p_bl", eq="(1+z1*beta-z2*beta)*p_bl(-1)"),
	list(var="p_bl_e",equ = "p_bl_e(-1)-betae*(p_bl_e(-1) - p_bl) + add")))
#Removing all existing scenarios (coming from LP)
lp2$scenarios<-NULL
#Checking that the model is complete
lp2<-sfc.check(lp2,fill=F)
#Adding the scenario
lp2<-sfc.addScenario(model=lp2,vars=list(c("r_bar")),values=list(c(0.035)),inits=1960,
											ends=2000)
lp2<-sfc.addScenario(model=lp2,vars=list(c("add")),values=list(c(-3)),inits=c(1955),
											ends=1955)
```

Let's have a look at the graph of model LP2

```{r,echo=T}
plot.dag(lp2)
```

We are now ready to simulate the model

```{r, echo=T}
datalp2<-simulate(lp2)
```

This replicates plot figure 5.5. p. 156

```{r,echo=T}
time2=c(1950:2000)
plot(time2,datalp2$scenario_1[as.character(time2),"r_b"],
     lty=2, lwd=2,type="l",ylab="",xlab="",ylim=c(0.029,0.036))
par(new=T)
plot(time2, datalp2$scenario_1[as.character(time2),"r_bl"],
		 type="l",xlab="",axes=F,ylab="",lty=1,lwd=2,ylim=c(0.0495,0.052))
axis(4,pretty(c(0.0495,0.052)))
legend("bottomright",legend=c("Long term interest rate",
		"Short term interest rate"),lty=c(1,2),lwd=2,bty="n")
grid()
```


This replicates plot figure 5.6. p. 156
```{r,echo=T}
time2=c(1950:2000)
matplot(time2, datalp2$scenario_1[as.character(time2),c("TP","bot","top")],
		 type="l",xlab="",ylab="",lty=c(2,1,1), col=1,lwd=2)
legend(x=1950,y=0.502,legend=c("Share of bonds in government debt held by households"),
			 lty=c(2),lwd=2,bty="n")
grid()
```

Let's add a second scenario by which there is an expected fall in the price of long-term bonds.

```{r,echo=T}
lp2<-sfc.addScenario(model=lp2,vars=list(c("add")),values=list(c(-3)),inits=c(1955),
											ends=1955)
datalp2<-simulate(lp2)
```

This replicates plot figure 5.7. p. 157
```{r,echo=T}
time2=c(1950:2000)
matplot(time2, datalp2$scenario_2[as.character(time2),c("r_bl")],
		 type="l",xlab="",ylab="",lty=c(2,1,1), col=1,lwd=2)
legend(x=1950,y=0.502,legend=c("Share of bonds in government debt held by households"),
			 lty=c(2),lwd=2,bty="n")
grid()
```

This replicates plot figure 5.8. p. 158
```{r,echo=T}
time2=c(1950:2000)
matplot(time2, datalp2$scenario_2[as.character(time2),c("p_bl_e","p_bl")],
		 type="l",xlab="",ylab="",lty=c(1,2), col=1,lwd=2)
legend("center",legend=c("Expected price of bonds","Actual price of bonds"),
			 lty=c(1,2),lwd=2,bty="n")
grid()
```

This replicates plot figure 5.9. p. 158
```{r,echo=T}
time2=c(1950:2000)
matplot(time2, datalp2$scenario_2[as.character(time2),c("TP","bot","top")],
		 type="l",xlab="",ylab="",lty=c(2,1,1), col=1,lwd=2)
legend("center",legend=c("Share of bonds in government debt held by households"),
			 lty=c(2),lwd=2,bty="n")
grid()
```

# Modelling the firm: price, investment and profits

## The role of banks: credit creation and investment

- Firms will always have an investment function determining the desired level of production capacity.
	* Model BMW: $K^T=\kappa \cdot Y_{-1}$
- However, the realisation of investment might be constrained by banks credit, leading to an eventual different between desired investment and actual investment.
	* Model BMW: $I_d = \gamma \cdot (K^T-K_{-1})+DA$ where $\gamma$ can be interpreted as the outcome between firms and banks interactions.

## Functional income distribution

- The usual way to distribute income is between wage and profits (i.e. looking at wage share and profit share). 
	* It is however often forgotten that profits are then decomposed further between different type of profits: retained earnings and distributed dividends.
	* But that's not the end of the story: we can disaggregate even further profits between gross profits and net profits, the difference being 1. interest payments, 2. taxes and 3. capital amortisation
	* It is usually the net profits that are then distributed between retained earnings and dividends.
- In model BMW: depreciation allowances (amortisation) are accounted for explicitly ($DA= \delta.K_{-1}$), so are interest payments. We thus have the following functional distribution of income: $Y=WB+r_{l,-1}\cdot L_{-1} + DA$
	* Note that in this case, the wage bill is endogenous since both interests payments and depreciation depend only on past values
	
## Consumption function

- In model BWM, the consumption function contains an autonomous term: $C = \alpha_0+\alpha_1\cdot YD + \alpha_2 \cdot M_{-1}$.
	* The autonomous term plays an important role in the dynamics of the model as it "kick-starts" the model. It plays the same role as government expenditures in the previous model we've seen.
	
## Steady state of BMW

- Let's do it manually, starting from the list of equations:

```{r, echo=T, eval=FALSE}
#Supply of consumption goods - eq. 7.1
 c_s = c_d
#Supply of investment goods - eq. 7.2
 i_s = i_d
#Supply of labour - eq. 7.3
 n_s = n_d
#Transactions of the firms
#GDP - eq. 7.5
 y = c_s + i_s
#Wage bill - eq. 7.6
 wb_d = y - r_l(-1)*l_d(-1) - af
#Depreciation allowances - eq. 7.7
 af = delta*k(-1)
#Demand for bank loans - eq. 7.8
 l_d = l_d(-1) + i_d - af
#Transactions of households
#Disposable income - eq. 7.9
 yd = wb_s + r_m(-1)*m_h(-1)
#Bank deposits held by households - eq. 7.10
 m_h = m_h(-1) + yd - c_d
#The wage bill
#"Supply" of wages - eq. 7.13
 wb_s = w*n_s
#Labour demand - eq. 7.14
 n_d = y/pr
#Wage rate - eq. 7.15
 w = wb_d/n_d
#Household behaviour
#Demand for consumption goods - eq. 7.16
 c_d = alpha0 + alpha1*yd + alpha2*m_h(-1)
#The investment behaviour
#Accumulation of capital - eq. 7.17
 k = k(-1) + i_d - da
#Depreciation allowances - eq. 7.18
 da = delta*k(-1)
#Capital stock target - eq. 7.19
 k_t = kappa*y(-1)
# below is an additional equation I've defined to get output to capital ratio as in figure 7.4, the model will run even without equation
OCR = y/k(-1)  
#Demand for investment goods - eq. 7.20
 i_d = gamma*(k_t - k(-1)) + da
```

- Important points to discuss:
	* Role of autonomous consumption
	* The existence of non-negative GDP steady state
	* The equality between capital stock and wealth

## Out of equilibrium values

- To do so, let's have a look at the graph representation of BMW:

```{r,eval=T,echo=T}
BMW<-sfc.model("Models/BMW.txt")
plot.dag(BMW)
```

- We need to solve the pink cycle and express Y (and K) as a function of only lagged variables.

## Stability

- Very brief intro because stability analysis of difference system is much more complicated than for differential systems.
- The stability of a system of equations $z_t = A \cdot z_{t-1} + c$ can be analysed via the trace, determinant and discriminant of A
	* trace = sum of diagonal terms, for 2x2 matrix: $tr_A = a_{11}+a_{22}$
	* determinant, for a 2x2 matrix: $det_A = |A| = a_{11}\cdot a_{22} - a_{21}\cdot a_{12}$
	* discriminant: $\Delta = tr_A^2+4\cdot det_A$
- Necessary condition for stability is that they absolute value of the determinant is smaller than 1
- If this is respected, then either the determinant is positive or if it is negative, the trace has to be smaller than 2 if and only if $-det_a<1-|tr_A|$.
- We won't go in the details, but the analysis highlight some important characteristics:
	* the system will converge provided the marginal propensity to save is higher than the marginal propensity to invest
	
## More on profits and inventories

- Inventories are fundamental for the working of a firm in terms of production smoothing, response to sudden changes in demand and dealing with uncertainty. They are very much related to the notion of time in SFC (and other types of post-Keynesian) models. Time is historical, based on past observation and projected in the future by expectations, on the contrary of mainstream models where the future is pulled in the present.
- Example of a current account matrix for firms

|Components| Firms Current account| Firms Capital account|
|:----:|:---:|:----:|
|Sales| $+S$||
|Change in the value of inventories| +$\Delta IN$| -$\Delta IN$|
|Wages| $-WB$||
|Interest on loans| $-r_{l-1}  L_{-1}$||
|Entrepreneurial profits| $-F$||
|Change in loans| $+\Delta L$||
|Sum| 0| 0|

- Entrepreneurial vs. total profits
	* Entrepreneurial profits: $F=S-(WB-\Delta IN + r_{l,-1} IN_{-1})$
	* Total profits: $F=S-(WB-\Delta IN)$
- Historical wage costs vs. total historic costs
	* Historical wage costs: $HWC = (WB-\Delta IN)$
	* Total historical costs: $HC = (WB-\Delta IN)+r_{l,-1} IN_{-1}$
- We can show that profits can always be expressed as a fraction of historical costs: $F= \phi' HC$, implying that sales can also be expressed as a function of historical costs only
	* $S = F + HC$
	* $S = (1+\phi')HC$
	* But Sales are also $S = s.p$, we can thus show that $p = (1+\phi')HUC$ where $HUC=\frac{HC}{s}$ is the historical unit cost.
- Important distinction between entrepreneurial profits and cash flows and the definition of national accounts profits
	* Entrepreneurial profits: $F=S-(WB-\Delta IN + r_{l,-1} IN_{-1})$
	* Cash flow: $CF=S - WB - r_{l,-1} IN_{-1}$
	* NIPA profits: $F_{nipa}=S - WB + \Delta IN - \Delta UC in_{-1}$ in order to remove stock appreciation or inventory valuation adjustment which are not "proper flows"

# References
